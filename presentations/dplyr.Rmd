---
title: "dplyr"
output: 
  ioslides_presentation:
    widescreen: true
---

## the dplyr package

user-contributed package that has kind of revolutionized working with data in R.

It provides a consistent and simpler interface to do things that you could also do using loops or base functions in R. 

It is less flexible than a for loop or `lapply()`, but it is easier to use, and works for the most common data manipulation tasks. 

## the dplyr package

`dplyr` is very consistent

it assumes that you are starting with a dataframe, doing something to that dataframe, and finishing with a different dataframe. 

Many of the base R functions operate on atomic vectors, which makes it more complicated to apply them to dataframes.) 

`dplyr` introduces a series of simple 'verbs' that describe many common data manipulation tasks. 

## Challenge 

We will use a dataset on student loans in public and private universities.

Read in this dataset called [DMV_2014_Q3_Undergrad_DirectLoans.txt](http://wabarr.github.io/hompal-stats/datasets/DMV_2014_Q3_Undergrad_DirectLoans.txt) and save it to a variable called `loans`.


```{r echo = FALSE}
loans <- read.table("http://wabarr.github.io/hompal-stats/datasets/DMV_2014_Q3_Undergrad_DirectLoans.txt", sep=",", header=TRUE)
```


## The basic dplyr verbs

There are a few basic functions in `dplyr`

The first argument to these functions is always the dataframe that you want to manipulate. 

Within these function calls, you can refer to the names of columns in the dataframe without quotation marks and without the usual `$` syntax. 

```{r warning=FALSE, message=FALSE}
library(dplyr)
```

## `filter()` 

This function selects a subset of rows meeting some criterion.  Note that the result is a dataframe. 

```{r warning=FALSE, message=FALSE}
filter(loans, School=="GEORGE WASHINGTON UNIVERSITY")
```

## `arrange()`

This function is like the "sort" function in MS Excel.  You simply provide a list of column names to sort by:

```{r}
arrange(loans, State, SubsidizedDL)
arrange(loans, State, desc(SubsidizedDL))
```

## `select()`

This function pulls out columns of interest.  You can select ranges of columns using the `:` operator syntax. (Note: usually this only works with numeric data, but this is a special usage defined in the `dplyr` package)

```{r}
select(loans, State, SubsidizedDL)
select(loans, -State, -SubsidizedDL)
select(loans, State:SubsidizedDL)
```

## `distinct()`

This function extracts the distinct rows.  It is most useful when combined with select

```{r}
distinct(loans)
distinct(select(loans, State, School_Type))
```

## `mutate()`

Adds new columns that are some function of existing columns

```{r}
mutate(loans, Total_Loans = SubsidizedDL + UNSubsidizedDL)
```

## `rowwise()`

Mutate works as expected when you want to manipulate whole columns at once, but sometimes you want to do something on a row-by-row basis.

For example: this code doesn't work as you might expect

```{r}
myDF <- data.frame(x=c(1,2,3), y=c(10, 11, 12))
mutate(myDF, sum=sum(x, y))
```

## `rowwise()`

But this code computes the sum on a row-by-row basis, as you might expect

```{r}
myDF <- data.frame(x=c(1,2,3), y=c(10, 11, 12))
mutate(rowwise(myDF), sum=sum(x, y))
```


## `summarise()`

Summarizes data into a single row.  This may seem not that useful, but it will become useful when we start grouping data. 

```{r}
summarise(loans, meanSubDL = mean(SubsidizedDL, na.rm=TRUE))
```


## Grouping Data

These functions above get really powerful when you start grouping data based on factors in your dataset.

##`group_by()`

```{r}
groupedLoans <- group_by(loans, State)
summarise(groupedLoans, meanSubDL = mean(SubsidizedDL, na.rm=TRUE))
```

## Chaining operations

`dplyr` also provides a way of chaining together complicated operations with the `%>%` operator.

This prevents having to save intermediate steps, or to have a complicated series of nested functions.

Note that the resulting dataframe from each step is passed as the first argument to the next function in the chain.

## Chaining operations

```{r}
group_by(loans, School_Type) %>%
  mutate(Total_Loans = SubsidizedDL + UNSubsidizedDL) %>%
  select(-State) %>%
  summarise(mean_total_loans = mean(Total_Loans, na.rm=TRUE))
```

## Chaining works with non-`dplyr()` functions too

```{r warning=FALSE}
#chained syntax
rnorm(1000, mean=20, sd=1.4) %>% log %>% hist(main="my nice histogram")


#compare with nested function calls 

hist(log(rnorm(1000, mean=20, sd=1.4)))
```

## `do()`

do anything to grouped data

```{r}
linearModels <- loans %>% group_by(State) %>%
  do(regression=lm(UNSubsidizedDL~SubsidizedDL, data=.))
linearModels
```

## `do()`


<pre class="prettyprint lang-r">
linearModels <- loans %>% group_by(State) %>%
  do(regression=lm(UNSubsidizedDL~SubsidizedDL, data=.))
linearModels
</pre>

```{r}
linearModels %>% 
  summarize(sum=summary(regression)$r.squared)
```


## Challenge

Using the `diamonds` dataset that is built in to the `ggplot2` package:

*  calculate the mean price of diamonds for each of the different clarity ratings
*  create a new column called `volume` that is the product of x, y and z
*  plot `volume` against `carat`

## More info

A more complete introduction is available in the [`dplyr` vignette](http://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html)

More info on `magrittr` [can be found here](http://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html).